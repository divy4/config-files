#!/usr/bin/env python3
from typing import Dict, Iterable, Set, Tuple
from functools import cache

import argparse
import collections
import itertools
import logging
import numpy  # TODO: Check numpy for entropy quality
import os
import sys
import tabulate

# Custom types
Finger = int
Location = numpy.ndarray
Locations = Iterable[Location]
LocationLike = str | Location | Locations

LOG_FORMAT = "%(levelname)s - %(message)s"

logger = logging.getLogger("generate_password")


# Temporary definition for typing purposes.
class Keyboard:
    pass


def generate_password(
    length: int,  # The length of the password to generate.
    lowercase: bool = True,  # If lowercase letters can be in the password.
    uppercase: bool = True,  # If uppercase letters can be in the password.
    digits: bool = True,  # If digits can be in the password.
    symbols: bool = True,  # If password-safe symbols can be in the password.
    unsafe_symbols: bool = False,  # If password-unsafe symbols can be in the password.
) -> str:
    """Generates a random password."""
    keyboard = Keyboard(
        lowercase=lowercase,
        uppercase=uppercase,
        digits=digits,
        symbols=symbols,
        unsafe_symbols=unsafe_symbols,
    )
    password = []
    entropy = 0
    for i in range(length):
        chars, p = get_char_probability(keyboard, password)
        entropy += compute_entropy(p)
        password.append(numpy.random.choice(chars, p=p))

    log_password_stats(len(keyboard.chars), length, entropy)
    return "".join(password)


def get_char_probability(
    keyboard: Keyboard,  # The keyboard being used.
    password: Iterable[str],  # The password so far.
) -> Tuple[numpy.ndarray[str], numpy.ndarray[float], float]:
    """Computes the probability of each character being selected next in the
    password.

    Return types:
      1: a numpy array of each character
      2: a numpy array of the probability of each character being selected
    """
    chars, reachability = keyboard.get_char_reachability(password)
    p = reachability / reachability.sum()
    return chars, p


def compute_entropy(p: numpy.ndarray[float]) -> float:
    """Computes the entropy of a probability distribution."""
    p_norm = p / p.sum()
    return sum(-x * numpy.log2(x) for x in p_norm if x > 0)


def log_password_stats(
    num_chars: int,  # The number of unique characters available for the password.
    length: int,  # The length of the password generated.
    entropy: float,  # The entropy of the password generated.
) -> None:
    """Generates useful stats about the password generated."""

    headers = compute_password_stats()
    data = []
    # Compute stats of generated password
    data.append(compute_password_stats("Generated", length, entropy))
    # Compute stats of random passwords
    random_entropy = compute_entropy(numpy.ones(num_chars))
    lengths = {
        length,
        numpy.floor(entropy / random_entropy),
        numpy.ceil(entropy / random_entropy),
    }
    for length in sorted(lengths):
        data.append(compute_password_stats("Random", length, random_entropy * length))
    # Print it as a table
    table = tabulate.tabulate(data, headers, stralign="right")
    logger.info(f"Password info:\n{table}")


def compute_password_stats(
    title: str = None,  # A title to give the password.
    length: int = None,  # The length of the password.
    entropy: float = None,  # The entropy of the password.
) -> Tuple[str, str, str, str]:
    """Computes stats for a single password."""
    if title is None:
        return ("", "Length", "Entropy", "Brute Force Time")

    brute_force = 2**entropy / 10000000000 / 3600 / 24 / 365.25
    return (
        title,
        f"{length:.0f} chars",
        f"{entropy:.1f} bits",
        f"{brute_force:.4g} years",
    )


class Keyboard:
    """A class for a set of hands interacting with a keyboard."""

    ##### Keyboard-specific settings #####

    # The keys each finger rests on (including thumbs)
    home_row = "asdf  jkl;"
    # What columns each finger is responsible for.
    # 0=left pinky, 4=left thumb, 5=right thumb, 9=right pinky
    column_to_finger = "0012336667899"
    # Each row of keys on the keyboard, when shift isn't pressed.
    # Capital S = Shift key
    keys = (
        "`12345=67890-",
        " qwert yuiop\\",
        " asdfg hjkl;'",
        "Szxcvb nm,./S",
        "          [] ",
    )
    # Each row of keys on the keyboard, when shift is pressed.
    shift_keys = (
        "~!@#$%+^&*()_",
        " QWERT YUIOP|",
        ' ASDFG HJKL:"',
        " ZXCVB NM<>? ",
        "          {} ",
    )
    # Each set of characters that could be used in a password.
    lowercase = "abcdefghijklmnopqrstuvwxyz"
    uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    digits = "0123456789"
    symbols = "_-,:!?.()[]{}@*#%^+<=>~"
    # TODO: Add space support
    unsafe_symbols = ";'\"/\\&`|$"

    ##### Reachability #####

    def get_char_reachability(
        self,
        pressed_chars: Iterable[str] = tuple(),  # What chars have been entered so far.
    ) -> Tuple[numpy.ndarray[str], numpy.ndarray[float]]:
        """Returns a score of how "reachable" a character is, given what
        characters have been pressed.

        Return type is a numpy array of each valid character and a second
        numpy array of the same size, where each"""
        reachability = numpy.ones(len(self.chars))
        # If nothing has been pressed, return equal probability for all characters
        if not pressed_chars:
            return self.chars, reachability

        # Compute reachability for each character
        for i, char in enumerate(self.chars):
            last_char = pressed_chars[-1]
            if self.__uses_same_finger(last_char, char):
                reachability[i] = 0
            if self.__is_finger_stretch(last_char, char):
                reachability[i] = 0
        return self.chars, reachability

    ##### Finger positioning #####

    def __is_finger_stretch(self, finger1: LocationLike, finger2: LocationLike) -> bool:
        """Returns true if two character/location/set of locations would stretch
        two fingers on the same hand in opposite directions."""
        left_locations = []
        right_locations = []
        # Find each location that belongs to the left or right hand
        for finger in finger1, finger2:
            for location in self.__to_locations(finger):
                if self.__uses_left_hand(location):
                    left_locations.append(location)
                else:
                    right_locations.append(location)
        # For each hand...
        for locations in left_locations, right_locations:
            # Compute the offset each finger is making to reach each key
            offsets = tuple(
                x - self.finger_map[self.__get_finger(x)] for x in locations
            )
            # For each pair of key locations...
            for location1, location2 in itertools.combinations(offsets, 2):
                distance = numpy.linalg.norm(
                    (location1 - location2) / numpy.array((2, 3))
                )
                if distance >= 1:
                    return True
        return False

    def __uses_different_hands(self, a: LocationLike, b: LocationLike) -> bool:
        """Returns true if two character/location/set of locations use different
        hands."""
        return (self.__uses_only_left_hand(a) and self.__uses_only_right_hand(b)) or (
            self.__uses_only_right_hand(a) and self.__uses_only_left_hand(b)
        )

    def __uses_only_same_hand(self, a: LocationLike, b: LocationLike) -> bool:
        """Returns true if two character/location/set of locations use different
        hands."""
        return (self.__uses_only_left_hand(a) and self.__uses_only_left_hand(b)) or (
            self.__uses_only_right_hand(a) and self.__uses_only_right_hand(b)
        )

    def __uses_same_hand(self, a: LocationLike, b: LocationLike) -> bool:
        """Returns true if two character/location/set of locations use the same
        single hand to type."""
        return (self.__uses_left_hand(a) and self.__uses_left_hand(b)) or (
            self.__uses_right_hand(a) and self.__uses_right_hand(b)
        )

    def __uses_both_hands(self, x: LocationLike) -> bool:
        """Returns true if a char/location/locations uses both hands."""
        return self.__uses_left_hand(x) and self.__uses_right_hand(x)

    def __uses_only_right_hand(self, x: LocationLike) -> bool:
        """Returns true if a char/location/locations uses only the right hand."""
        return all(not self.__is_left_finger(f) for f in self.__to_fingers(x))

    def __uses_right_hand(self, x: LocationLike) -> bool:
        """Returns true if a char/location/locations uses the right hand."""
        return any(not self.__is_left_finger(f) for f in self.__to_fingers(x))

    def __uses_only_left_hand(self, x: LocationLike) -> bool:
        """Returns true if a char/location/locations uses only the left hand."""
        return all(self.__is_left_finger(f) for f in self.__to_fingers(x))

    def __uses_left_hand(self, x: LocationLike) -> bool:
        """Returns true if a char/location/locations uses the left hand."""
        return any(self.__is_left_finger(f) for f in self.__to_fingers(x))

    def __uses_same_finger(self, a: LocationLike, b: LocationLike) -> bool:
        """Returns true if a character/location/set of locations uses the same
        finger as another character/location/set of locations."""
        return bool(self.__to_fingers(a) & self.__to_fingers(b))

    def __to_fingers(self, x: LocationLike) -> Set[Finger]:
        """Converts a char, location, or Locations into fingers."""
        return set(self.__get_finger(l) for l in self.__to_locations(x))

    def __to_locations(self, x: LocationLike) -> Locations:
        """Converts a char, Location, or Locations into Locations."""
        if isinstance(x, str):
            return self.char_map[x]
        elif isinstance(x, numpy.ndarray):
            return (x,)
        elif isinstance(x, Tuple):
            return x
        raise ValueError(f"Unable to convert {x} into Locations.")

    def __is_left_finger(self, f: Finger) -> bool:
        """Returns true if a finger is a left finger."""
        return f < 5

    def __get_finger(self, l: Location) -> Finger:
        """Returns the finger that presses a location."""
        return int(self.column_to_finger[l[0]])

    ##### Initialization / Location mapping #####

    def __init__(self, **kwargs):
        """Create a Keyboard instance."""
        self.set_valid_chars(**kwargs)
        self.__compute_char_map()
        self.__compute_finger_map()

    def set_valid_chars(
        self,
        lowercase: bool,  # If lowercase letters can be in the password.
        uppercase: bool,  # If uppercase letters can be in the password.
        digits: bool,  # If digits can be in the password.
        symbols: bool,  # If password-safe symbols can be in the password.
        unsafe_symbols: bool,  # If password-unsafe symbols can be in the password.
    ) -> None:
        """Sets what characters can be in the password."""
        chars = []
        if lowercase:
            chars.extend(self.lowercase)
        if uppercase:
            chars.extend(self.uppercase)
        if digits:
            chars.extend(self.digits)
        if symbols:
            chars.extend(self.symbols)
        if unsafe_symbols:
            chars.extend(self.unsafe_symbols)
        self.chars = numpy.array(chars)

    def __compute_char_map(self) -> None:
        """Computes the location of each character on the keyboard."""
        logger.debug("Generating character location map...")
        self.char_map = {}
        for key_set_name, key_set in (
            ("keys", self.keys),
            ("shift_keys", self.shift_keys),
        ):
            for y, key_row in enumerate(key_set):
                if len(self.column_to_finger) != len(key_row):
                    raise ValueError(
                        f"Row {y} of self.{key_set_name} has a different number"
                        f" of columns than self.column_to_finger"
                        f" ({len(key_row)} vs {len(self.column_to_finger)})."
                    )
                for x, char in enumerate(key_row):
                    location = numpy.array((x, y))
                    finger = self.__get_finger(location)
                    if char == " ":
                        continue
                    # Special keys
                    elif key_set_name == "keys" and char.isupper():
                        if char == "S":
                            if self.__is_left_finger(finger):
                                self.char_map["LEFT_SHIFT"] = (location,)
                            else:
                                self.char_map["RIGHT_SHIFT"] = (location,)
                    # Shift keys
                    elif key_set_name == "shift_keys":
                        # Press right shift with left-fingered keys
                        if self.__is_left_finger(finger):
                            self.char_map[char] = (
                                location,
                                *self.char_map["RIGHT_SHIFT"],
                            )
                        # And press left shift with right-fingered keys
                        else:
                            self.char_map[char] = (
                                location,
                                *self.char_map["LEFT_SHIFT"],
                            )
                    # Normal keys
                    else:
                        self.char_map[char] = (location,)

    def __compute_finger_map(self) -> None:
        """Computes the location of each finger on the keyboard."""
        logger.debug("Generating finger location map...")
        self.finger_map = {}
        for finger, resting_char in enumerate(self.home_row):
            # TODO: Add thumb support
            if resting_char == " ":
                continue
            self.finger_map[finger] = self.char_map[resting_char][0]


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog=os.path.basename(__file__))
    parser.add_argument(
        "length",
        type=int,
        help="The number of characters to include in the password.",
    )
    parser.add_argument(
        "--log",
        choices=("trace", "debug", "info", "warning", "error"),
        default="warning",
        help="The level to log at. Defaults to warning.",
    )
    parser.add_argument(
        "-l",
        "--lowercase",
        action="store_const",
        const=True,
        help=(
            "If lowercase letters can be in the password."
            " Defaults to true unless any of -udsn are given."
        ),
    )
    parser.add_argument(
        "-u",
        "--uppercase",
        action="store_const",
        const=True,
        help=(
            "If uppercase letters can be in the password."
            " Defaults to true unless any of -ldsn are given."
        ),
    )
    parser.add_argument(
        "-d",
        "--digits",
        action="store_const",
        const=True,
        help=(
            "If digits can be in the password."
            " Defaults to true unless any of -lusn are given."
        ),
    )
    parser.add_argument(
        "-s",
        "--symbols",
        action="store_const",
        const=True,
        help=(
            "If password-safe symbols can be in the password."
            " Defaults to true unless any of -ludn are given."
        ),
    )
    parser.add_argument(
        "-n",
        "--unsafe-symbols",
        action="store_const",
        const=True,
        help=(
            "If password-unsafe symbols can be in the password."
            " Defaults to false unless any of -luds are given."
        ),
    )
    args = parser.parse_args(sys.argv[1:])

    # Defaults for character set flags
    if (
        args.lowercase is None
        and args.uppercase is None
        and args.digits is None
        and args.symbols is None
        and args.unsafe_symbols is None
    ):
        # All true except unsafe symbols if none are given
        args.lowercase = True
        args.uppercase = True
        args.digits = True
        args.symbols = True
        args.unsafe_symbols = False
    else:
        # All default to false if any are given
        args.lowercase = args.lowercase or False
        args.uppercase = args.uppercase or False
        args.digits = args.digits or False
        args.symbols = args.symbols or False
        args.unsafe_symbols = args.unsafe_symbols or False

    logging.basicConfig(level=args.log.upper(), format=LOG_FORMAT)

    print(
        generate_password(
            length=args.length,
            lowercase=args.lowercase,
            uppercase=args.uppercase,
            digits=args.digits,
            symbols=args.symbols,
            unsafe_symbols=args.unsafe_symbols,
        )
    )
