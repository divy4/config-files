#!/usr/bin/env python3
from typing import Dict, Generator, Iterable, Set, Tuple
from functools import cache

import argparse
import collections
import enum
import itertools
import logging
import numpy  # TODO: Check numpy for entropy quality
import os
import sys
import tabulate


# Temporary definition for typing purposes.
class Finger:
    pass


class Hands:
    pass


class Keyboard:
    pass


# Custom types
class Finger(enum.Enum):
    LEFT_PINKY = 0
    LEFT_RING = 1
    LEFT_MIDDLE = 2
    LEFT_INDEX = 3
    LEFT_THUMB = 4
    RIGHT_THUMB = 5
    RIGHT_INDEX = 6
    RIGHT_MIDDLE = 7
    RIGHT_RING = 8
    RIGHT_PINKY = 9

    def get_fingers() -> Generator[Finger, None, None]:
        """Yields every finger."""
        for x in Finger:
            try:
                if isinstance(x, Finger):
                    yield x
            except TypeError:
                pass

    def is_left(self):
        """Returns true if a finger is a left finger."""
        return self.value < 5

    def is_right(self):
        """Returns true if a finger is a right finger."""
        return self.value > 4

    def __repr__(self):
        return self.name


Location = numpy.ndarray
KeyPress = Tuple[Finger, Location]

LOG_FORMAT = "%(levelname)s - %(message)s"

logger = logging.getLogger("generate_password")


def generate_password(
    length: int,  # The length of the password to generate.
    lowercase: bool = True,  # If lowercase letters can be in the password.
    uppercase: bool = True,  # If uppercase letters can be in the password.
    digits: bool = True,  # If digits can be in the password.
    symbols: bool = True,  # If password-safe symbols can be in the password.
    unsafe_symbols: bool = False,  # If password-unsafe symbols can be in the password.
) -> str:
    """Generates a random password."""
    keyboard = Keyboard(
        lowercase=lowercase,
        uppercase=uppercase,
        digits=digits,
        symbols=symbols,
        unsafe_symbols=unsafe_symbols,
    )
    hands = Hands(keyboard.resting_locations, keyboard.get_shift_locations())

    password = []
    entropy = 0
    for i in range(length):
        # Get a probability distribution for each character
        chars, p = get_char_probability(keyboard, hands, password)
        # Pick a character based on that distribution
        char = numpy.random.choice(chars, p=p)
        # Add it to the password
        password.append(char)
        # Record it to the hands
        hands.record_key_presses(keyboard.get_key_presses(char))
        # And add the amount of entropy that choice had to the total
        entropy += compute_entropy(p)

    log_password_stats(len(keyboard.chars), length, entropy)
    return "".join(password)


def get_char_probability(
    keyboard: Keyboard,  # The keyboard being used.
    hands: Hands,  # The hands typing the password.
    password: Iterable[str],  # The password so far.
) -> Tuple[Iterable[str], numpy.ndarray[float]]:
    """Computes the probability of each character being selected next in the
    password.

    Return types:
      1: an iterable of each character
      2: a numpy array of the probability of each character being selected
    """
    # Compute how hard it is to reach each key
    chars, reachability = zip(
        *[
            (char, hands.get_reachability(key_presses))
            for char, key_presses in keyboard.key_presses.items()
        ]
    )
    reachability = numpy.array(reachability)
    # Convert scores into a probability distribution
    p = reachability / reachability.sum()
    return chars, p


class Hands:
    """A class for a pair of hands typing."""

    def __init__(
        self,
        resting_locations: Dict[
            Finger, Location
        ],  # The locations where each finger rests.
        shift_keys: Iterable[Location],  # The locations of the shift keys.
    ):
        """Create a pair of hands."""
        self.__resting_locations = resting_locations
        self.__shift_keys = shift_keys
        self.reset()

    def reset(self):
        """Reset hands to their resting locations."""
        self.__time = -1
        self.__location_history = {}
        for finger, location in self.__resting_locations.items():
            self.__location_history[finger] = {self.__time: location}
        self.__time += 1

    def record_key_presses(
        self,
        key_presses: Iterable[KeyPress],  # A set of key presses to record.
    ) -> None:
        """Records a set of key presses."""
        for finger, location in key_presses:
            self.__location_history[finger][self.__time] = location
        self.__time += 1

    def get_reachability(
        self,
        key_presses: Iterable[KeyPress],  # A set of key trying to be pressed.
    ) -> float:
        """Returns how "reachable" pressing a set of keys at the same time
        would be."""
        reachability = 1
        for finger, location in key_presses:
            reachability *= self.__get_single_reachability(finger, location)
        return reachability

    def __get_single_reachability(
        self,
        finger: Finger,  # The finger pressing the key.
        location: Location,  # The location of the key being pressed.
    ) -> float:
        """Returns how "reachable" a single finger pressing a key would be."""
        # Get the last key press by this finger
        last_time, last_location = self.__get_last_press(finger)
        # Ignore if it hasn't pressed anything yet
        if last_time is None:
            return 1

        # Compute weighted distance and speed from last location and the new location
        distance = numpy.linalg.norm((location - last_location) / numpy.array([2, 3]))
        speed = distance / (self.__time - last_time)
        reachability = 1 / (speed + 1) ** 2

        # Modify reachability when pressing the same key...
        if numpy.array_equal(last_location, location):
            # ...immediately after...
            if last_time == self.__time - 1:
                # ...which is a shift key
                if self.__is_shift_location(location):
                    reachability *= 1.2
                # ...or not a shift key
                else:
                    reachability *= 0.1
            # ...or later
            else:
                reachability *= 1.1
        # Pressing a different key...
        else:
            # ...immediately after
            if last_time == self.__time - 1:
                reachability *= 0.1
            # ...or later
            else:
                reachability *= 1
        return reachability

    def __get_last_press(
        self,
        finger: Finger,  # The finger to check.
    ) -> Tuple[int, Location] | Tuple[None, None]:
        """Get the last key press of a finger within the last time_window presses."""
        # Get the last key press
        history = self.__location_history[finger]
        press_time, press_location = max(history.items())
        # Exit early if we reached the start of time or the time window
        if press_time == -1:
            return None, None
        # Return location of key press
        return press_time, press_location

    def __is_shift_location(self, location: Location) -> bool:
        """Returns true if a location is the location of a shift key."""
        for x in self.__shift_keys:
            if numpy.array_equal(location, x):
                return True
        return False


class Keyboard:
    """A class for a keyboard."""

    ##### Keyboard-specific settings #####

    # The keys each finger rests on (including thumbs)
    home_row = "asdf  jkl;"
    # What columns each finger is responsible for.
    # 0=left pinky, 4=left thumb, 5=right thumb, 9=right pinky
    column_to_finger = "0012336667899"
    # Each row of keys on the keyboard, when shift isn't pressed.
    # Capital S = Shift key
    keys = (
        "`12345=67890-",
        " qwert yuiop\\",
        " asdfg hjkl;'",
        "Szxcvb nm,./S",
        "          [] ",
    )
    # Each row of keys on the keyboard, when shift is pressed.
    shifted_keys = (
        "~!@#$%+^&*()_",
        " QWERT YUIOP|",
        ' ASDFG HJKL:"',
        " ZXCVB NM<>? ",
        "          {} ",
    )
    # Each set of characters that could be used in a password.
    lowercase = "abcdefghijklmnopqrstuvwxyz"
    uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    digits = "0123456789"
    symbols = "_-,:!?.()[]{}@*#%^+<=>~"
    # TODO: Add space support
    unsafe_symbols = ";'\"/\\&`|$"

    ##### Initialization / Location mapping #####

    def __init__(self, **kwargs):
        """Create a Keyboard instance."""
        self.set_valid_chars(**kwargs)
        self.key_presses, self.__shift_key_locations = self.__compute_key_press_map()
        self.resting_locations = self.__compute_home_row_map()

    def get_key_presses(self, char: str) -> Iterable[KeyPress]:
        """Returns the key press(es) needed to enter a character."""
        return self.key_presses[char]

    def get_shift_locations(self) -> Iterable[Location]:
        """Returns the locations of the shift keys."""
        return list(x[1] for x in self.__shift_key_locations.values())

    def get_resting_location(self, finger: Finger) -> Location:
        """Returns the resting location of a finger."""
        return self.__resting_locations[finger]

    def set_valid_chars(
        self,
        lowercase: bool,  # If lowercase letters can be in the password.
        uppercase: bool,  # If uppercase letters can be in the password.
        digits: bool,  # If digits can be in the password.
        symbols: bool,  # If password-safe symbols can be in the password.
        unsafe_symbols: bool,  # If password-unsafe symbols can be in the password.
    ) -> None:
        """Sets what characters can be in the password."""
        chars = []
        if lowercase:
            chars.extend(self.lowercase)
        if uppercase:
            chars.extend(self.uppercase)
        if digits:
            chars.extend(self.digits)
        if symbols:
            chars.extend(self.symbols)
        if unsafe_symbols:
            chars.extend(self.unsafe_symbols)
        self.chars = numpy.array(chars)

    def __compute_key_press_map(self) -> Dict[str, Iterable[KeyPress]]:
        """Computes the finger locations required to press each character
        on the keyboard."""
        logger.debug("Generating character location map...")
        key_press_map = {}
        shift_locations = {}
        for key_set_name, key_set in (
            ("keys", self.keys),
            ("shift_keys", self.shifted_keys),
        ):
            for y, key_row in enumerate(key_set):
                if len(self.column_to_finger) != len(key_row):
                    raise ValueError(
                        f"Row {y} of self.{key_set_name} has a different number"
                        f" of columns than self.column_to_finger"
                        f" ({len(key_row)} vs {len(self.column_to_finger)})."
                    )
                for x, char in enumerate(key_row):
                    location = numpy.array((x, y))
                    finger = self.__get_finger(location)
                    finger_location = (finger, location)
                    if char == " ":
                        continue
                    # Special keys
                    elif key_set_name == "keys" and char.isupper():
                        if char == "S":
                            if finger.is_left():
                                shift_locations["LEFT_SHIFT"] = finger_location
                            else:
                                shift_locations["RIGHT_SHIFT"] = finger_location
                    # Shift keys
                    elif key_set_name == "shift_keys":
                        # Figure out what shift key needs to be pressed
                        if finger.is_left():
                            shift_location = shift_locations["RIGHT_SHIFT"]
                        else:
                            shift_location = shift_locations["LEFT_SHIFT"]
                        # And then add the character location + shift
                        key_press_map[char] = (
                            finger_location,
                            shift_location,
                        )
                    # Normal keys
                    else:
                        key_press_map[char] = (finger_location,)
        return key_press_map, shift_locations

    def __compute_home_row_map(self) -> Dict[Finger, Location]:
        """Computes the location of each finger on the keyboard."""
        logger.debug("Generating finger location map...")
        home_row_map = {}
        for resting_char in self.home_row:
            # TODO: Add thumb support
            if resting_char == " ":
                continue
            finger, location = self.get_key_presses(resting_char)[0]
            home_row_map[finger] = location
        return home_row_map

    def __get_finger(self, l: Location) -> Finger:
        """Returns the finger that presses a location."""
        return Finger(int(self.column_to_finger[l[0]]))


# Stats


def compute_entropy(p: numpy.ndarray[float]) -> float:
    """Computes the entropy of a probability distribution."""
    p_norm = p / p.sum()
    return sum(-x * numpy.log2(x) for x in p_norm if x > 0)


def log_password_stats(
    num_chars: int,  # The number of unique characters available for the password.
    length: int,  # The length of the password generated.
    entropy: float,  # The entropy of the password generated.
) -> None:
    """Generates useful stats about the password generated."""
    headers = compute_password_stats()
    data = []
    # Compute stats of generated password
    data.append(compute_password_stats("Generated", length, entropy))
    # Compute stats of random passwords
    random_entropy = compute_entropy(numpy.ones(num_chars))
    lengths = {
        length,
        numpy.floor(entropy / random_entropy),
        numpy.ceil(entropy / random_entropy),
    }
    for length in sorted(lengths):
        data.append(compute_password_stats("Random", length, random_entropy * length))
    # Print it as a table
    table = tabulate.tabulate(data, headers, stralign="right")
    logger.info(f"Password info:\n{table}")


def compute_password_stats(
    title: str = None,  # A title to give the password.
    length: int = None,  # The length of the password.
    entropy: float = None,  # The entropy of the password.
) -> Tuple[str, str, str, str]:
    """Computes stats for a single password."""
    if title is None:
        return ("", "Length", "Entropy", "Brute Force Time")

    brute_force = 2**entropy / 10000000000 / 3600 / 24 / 365.25
    return (
        title,
        f"{length:.0f} chars",
        f"{entropy:.1f} bits",
        seconds_to_human_time(brute_force),
    )


# Time

SECOND_SECONDS = 1
MINUTE_SECONDS = 60
HOUR_SECONDS = MINUTE_SECONDS * 60
DAY_SECONDS = HOUR_SECONDS * 24
MONTH_SECONDS = DAY_SECONDS * 365.25 / 12
YEAR_SECONDS = MONTH_SECONDS * 12
DECADE_SECONDS = YEAR_SECONDS * 10
CENTURY_SECONDS = DECADE_SECONDS * 10
MILLENNIUM_SECONDS = CENTURY_SECONDS * 10
EON_SECONDS = MILLENNIUM_SECONDS * 1000000

TIME_COMPONENTS = (
    ("eon", "eons"),
    ("millennium", "millennia"),
    ("century", "centuries"),
    ("decade", "decades"),
    ("year", "years"),
    ("month", "months"),
    ("day", "days"),
    ("hour", "hours"),
    ("minute", "minutes"),
    ("second", "seconds"),
)


def seconds_to_human_time(total_seconds: float) -> str:
    """Converts seconds into a human-readable time string, rounded down to the
    1's place of the largest time component e.g. 2 days or 35 minutes."""
    remainder = total_seconds
    # For years/months/days/...
    for singular, plural in TIME_COMPONENTS:
        # Find the number of seconds in a year/month/day/...
        divider = globals()[f"{singular.upper()}_SECONDS"]
        # Compute the number of years/months/days/... and the remainder seconds left
        amount, remainder = divmod(remainder, divider)
        amount = round(amount)  # Convert to int
        if amount == 0:
            continue
        elif amount == 1:
            return f"{amount} {singular}"
        else:
            return f"{amount} {plural}"
    return "less than 1 second"


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog=os.path.basename(__file__))
    parser.add_argument(
        "length",
        type=int,
        help="The number of characters to include in the password.",
    )
    parser.add_argument(
        "--log",
        choices=("trace", "debug", "info", "warning", "error"),
        default="warning",
        help="The level to log at. Defaults to warning.",
    )
    parser.add_argument(
        "-l",
        "--lowercase",
        action="store_const",
        const=True,
        help=(
            "If lowercase letters can be in the password."
            " Defaults to true unless any of -udsn are given."
        ),
    )
    parser.add_argument(
        "-u",
        "--uppercase",
        action="store_const",
        const=True,
        help=(
            "If uppercase letters can be in the password."
            " Defaults to true unless any of -ldsn are given."
        ),
    )
    parser.add_argument(
        "-d",
        "--digits",
        action="store_const",
        const=True,
        help=(
            "If digits can be in the password."
            " Defaults to true unless any of -lusn are given."
        ),
    )
    parser.add_argument(
        "-s",
        "--symbols",
        action="store_const",
        const=True,
        help=(
            "If password-safe symbols can be in the password."
            " Defaults to true unless any of -ludn are given."
        ),
    )
    parser.add_argument(
        "-n",
        "--unsafe-symbols",
        action="store_const",
        const=True,
        help=(
            "If password-unsafe symbols can be in the password."
            " Defaults to false unless any of -luds are given."
        ),
    )
    args = parser.parse_args(sys.argv[1:])

    # Defaults for character set flags
    if (
        args.lowercase is None
        and args.uppercase is None
        and args.digits is None
        and args.symbols is None
        and args.unsafe_symbols is None
    ):
        # All true except unsafe symbols if none are given
        args.lowercase = True
        args.uppercase = True
        args.digits = True
        args.symbols = True
        args.unsafe_symbols = False
    else:
        # All default to false if any are given
        args.lowercase = args.lowercase or False
        args.uppercase = args.uppercase or False
        args.digits = args.digits or False
        args.symbols = args.symbols or False
        args.unsafe_symbols = args.unsafe_symbols or False

    logging.basicConfig(level=args.log.upper(), format=LOG_FORMAT)

    print(
        generate_password(
            length=args.length,
            lowercase=args.lowercase,
            uppercase=args.uppercase,
            digits=args.digits,
            symbols=args.symbols,
            unsafe_symbols=args.unsafe_symbols,
        )
    )
