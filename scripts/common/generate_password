#!/usr/bin/env python3
from typing import Dict, Iterable, Set, Tuple
from functools import cache

import argparse
import collections
import logging

# TODO: Check numpy for entropy quality
import numpy
import os
import sys

# Custom types
Finger = int
Location = numpy.ndarray
Locations = Iterable[Location]
LocationLike = str | Location | Locations

logger = logging.getLogger("generate_password")


# Temporary definition for typing purposes.
class Keyboard:
    pass


def generate_password(
    length: int,  # The length of the password to generate
    lowercase: bool = True,  # If lowercase letters can be in the password.
    uppercase: bool = True,  # If uppercase letters can be in the password.
    digits: bool = True,  # If digits can be in the password.
    symbols: bool = True,  # If password-safe symbols can be in the password.
    unsafe_symbols: bool = False,  # If password-unsafe symbols can be in the password.
) -> str:
    """Generates a random password."""
    keyboard = Keyboard(
        lowercase=lowercase,
        uppercase=uppercase,
        digits=digits,
        symbols=symbols,
        unsafe_symbols=unsafe_symbols,
    )
    password = []
    for i in range(length):
        chars, p = get_char_probability(keyboard, password)
        password.append(numpy.random.choice(chars, p=p))
    return "".join(password)


def get_char_probability(
    keyboard: Keyboard,  # The keyboard being used.
    password: Iterable[str],  # The password so far.
) -> Tuple[numpy.ndarray[str], numpy.ndarray[int]]:
    """Computes the probability of each character being selected next in the
    password.

    Return type is two numpy arrays of the same size, where the first is of each
    character and the second is the probability of that character being
    selected."""
    chars, p = keyboard.get_char_reachability(password)
    return chars, p / p.sum()


class Keyboard:
    """A class for a set of hands interacting with a keyboard."""

    ##### Keyboard-specific settings #####

    # The keys each finger rests on (including thumbs)
    home_row = "asdf  jkl;"
    # What columns each finger is responsible for.
    # 0=left pinky, 4=left thumb, 5=right thumb, 9=right pinky
    column_to_finger = "0012336667899"
    # Each row of keys on the keyboard, when shift isn't pressed.
    # Capital S = Shift key
    keys = (
        "`12345=67890-",
        " qwert yuiop\\",
        " asdfg hjkl;'",
        "Szxcvb nm,./S",
        "          [] ",
    )
    # Each row of keys on the keyboard, when shift is pressed.
    shift_keys = (
        "~!@#$%+^&*()_",
        " QWERT YUIOP|",
        ' ASDFG HJKL:"',
        " ZXCVB NM<>? ",
        "          {} ",
    )
    # Each set of characters that could be used in a password.
    lowercase = "abcdefghijklmnopqrstuvwxyz"
    uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    digits = "0123456789"
    symbols = "_-,:!?.()[]{}@*#%^+<=>~"
    # TODO: Add space support
    unsafe_symbols = ";'\"/\\&`|$"

    ##### Reachability #####

    def get_char_reachability(
        self,
        pressed_chars: Iterable[str] = tuple(),  # What chars have been entered so far.
    ) -> Tuple[numpy.ndarray[str], numpy.ndarray[float]]:
        """Returns a score of how "reachable" a character is, given what
        characters have been pressed.

        Return type is a numpy array of each valid character and a second
        numpy array of the same size, where each"""
        reachability = numpy.ones(len(self.chars))
        # If nothing has been pressed, return equal probability for all characters
        if not pressed_chars:
            return self.chars, reachability

        # Compute reachability for each character
        for i, char in enumerate(self.chars):
            last_char = pressed_chars[-1]
            if self.__uses_same_finger(last_char, char):
                reachability[i] = 0
            if self.__uses_only_same_hand(last_char, char):
                reachability[i] = 0
            if self.__is_finger_stretch(last_char, char):
                reachability[i] = 0

        return self.chars, reachability

    ##### Finger positioning #####

    def __is_finger_stretch(self, a: LocationLike, b: LocationLike) -> bool:
        """Returns true if two character/location/set of locations would stretch
        two fingers on the same hand in opposite directions."""
        left_locations = []
        right_locations = []
        # Find each location that belongs to the left or right hand
        for x in a, b:
            for l in self.__to_locations(x):
                if self.__uses_left_hand(l):
                    left_locations.append(l)
                else:
                    right_locations.append(l)
        #
        for locations in left_locations, right_locations:
            # Compute the offset each finger is making to reach the location
            offsets = tuple(
                x - self.finger_map[self.__get_finger(x)] for x in locations
            )
            for ix, x in enumerate(offsets):
                for y in offsets[ix + 1 : :]:
                    abs_diff = abs(y - x)
                    if abs_diff[0] >= 2:
                        return True
                    elif abs_diff[1] >= 3:
                        return True
        return False

    def __uses_different_hands(self, a: LocationLike, b: LocationLike) -> bool:
        """Returns true if two character/location/set of locations use different
        hands."""
        return (self.__uses_only_left_hand(a) and self.__uses_only_right_hand(b)) or (
            self.__uses_only_right_hand(a) and self.__uses_only_left_hand(b)
        )

    def __uses_only_same_hand(self, a: LocationLike, b: LocationLike) -> bool:
        """Returns true if two character/location/set of locations use different
        hands."""
        return (self.__uses_only_left_hand(a) and self.__uses_only_left_hand(b)) or (
            self.__uses_only_right_hand(a) and self.__uses_only_right_hand(b)
        )

    def __uses_same_hand(self, a: LocationLike, b: LocationLike) -> bool:
        """Returns true if two character/location/set of locations use the same
        single hand to type."""
        return (self.__uses_left_hand(a) and self.__uses_left_hand(b)) or (
            self.__uses_right_hand(a) and self.__uses_right_hand(b)
        )

    def __uses_both_hands(self, x: LocationLike) -> bool:
        """Returns true if a char/location/locations uses both hands."""
        return self.__uses_left_hand(x) and self.__uses_right_hand(x)

    def __uses_only_right_hand(self, x: LocationLike) -> bool:
        """Returns true if a char/location/locations uses only the right hand."""
        return all(not self.__is_left_finger(f) for f in self.__to_fingers(x))

    def __uses_right_hand(self, x: LocationLike) -> bool:
        """Returns true if a char/location/locations uses the right hand."""
        return any(not self.__is_left_finger(f) for f in self.__to_fingers(x))

    def __uses_only_left_hand(self, x: LocationLike) -> bool:
        """Returns true if a char/location/locations uses only the left hand."""
        return all(self.__is_left_finger(f) for f in self.__to_fingers(x))

    def __uses_left_hand(self, x: LocationLike) -> bool:
        """Returns true if a char/location/locations uses the left hand."""
        return any(self.__is_left_finger(f) for f in self.__to_fingers(x))

    def __uses_same_finger(self, a: LocationLike, b: LocationLike) -> bool:
        """Returns true if a character/location/set of locations uses the same
        finger as another character/location/set of locations."""
        return bool(self.__to_fingers(a) & self.__to_fingers(b))

    def __to_fingers(self, x: LocationLike) -> Set[Finger]:
        """Converts a char, location, or Locations into fingers."""
        return set(self.__get_finger(l) for l in self.__to_locations(x))

    def __to_locations(self, x: LocationLike) -> Locations:
        """Converts a char, Location, or Locations into Locations."""
        if isinstance(x, str):
            return self.char_map[x]
        elif isinstance(x, numpy.ndarray):
            return (x,)
        elif isinstance(x, Tuple):
            return x
        raise ValueError(f"Unable to convert {x} into Locations.")

    def __is_left_finger(self, f: Finger) -> bool:
        """Returns true if a finger is a left finger."""
        return f < 5

    def __get_finger(self, l: Location) -> Finger:
        """Returns the finger that presses a location."""
        return int(self.column_to_finger[l[0]])

    ##### Initialization / Location mapping #####

    def __init__(self, **kwargs):
        """Create a Keyboard instance."""
        self.set_valid_chars(**kwargs)
        self.__compute_char_map()
        self.__compute_finger_map()

    def set_valid_chars(
        self,
        lowercase: bool,  # If lowercase letters can be in the password.
        uppercase: bool,  # If uppercase letters can be in the password.
        digits: bool,  # If digits can be in the password.
        symbols: bool,  # If password-safe symbols can be in the password.
        unsafe_symbols: bool,  # If password-unsafe symbols can be in the password.
    ) -> None:
        """Sets what characters can be in the password."""
        chars = []
        if lowercase:
            chars.extend(self.lowercase)
        if uppercase:
            chars.extend(self.uppercase)
        if digits:
            chars.extend(self.digits)
        if symbols:
            chars.extend(self.symbols)
        if unsafe_symbols:
            chars.extend(self.unsafe_symbols)
        self.chars = numpy.array(chars)

    def __compute_char_map(self) -> None:
        """Computes the location of each character on the keyboard."""
        logger.debug("Generating character location map...")
        self.char_map = {}
        for key_set_name, key_set in (
            ("keys", self.keys),
            ("shift_keys", self.shift_keys),
        ):
            for y, key_row in enumerate(key_set):
                if len(self.column_to_finger) != len(key_row):
                    raise ValueError(
                        f"Row {y} of self.{key_set_name} has a different number"
                        f" of columns than self.column_to_finger"
                        f" ({len(key_row)} vs {len(self.column_to_finger)})."
                    )
                for x, char in enumerate(key_row):
                    location = numpy.array((x, y))
                    finger = self.__get_finger(location)
                    if char == " ":
                        continue
                    # Special keys
                    elif key_set_name == "keys" and char.isupper():
                        if char == "S":
                            if self.__is_left_finger(finger):
                                self.char_map["LEFT_SHIFT"] = (location,)
                            else:
                                self.char_map["RIGHT_SHIFT"] = (location,)
                    # Shift keys
                    elif key_set_name == "shift_keys":
                        # Press right shift with left-fingered keys
                        if self.__is_left_finger(finger):
                            self.char_map[char] = (
                                location,
                                *self.char_map["RIGHT_SHIFT"],
                            )
                        # And press left shift with right-fingered keys
                        else:
                            self.char_map[char] = (
                                location,
                                *self.char_map["LEFT_SHIFT"],
                            )
                    # Normal keys
                    else:
                        self.char_map[char] = (location,)

    def __compute_finger_map(self) -> None:
        """Computes the location of each finger on the keyboard."""
        logger.debug("Generating finger location map...")
        self.finger_map = {}
        for finger, resting_char in enumerate(self.home_row):
            # TODO: Add thumb support
            if resting_char == " ":
                continue
            self.finger_map[finger] = self.char_map[resting_char][0]


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog=os.path.basename(__file__))
    parser.add_argument(
        "length",
        type=int,
        help="The number of characters to include in the password.",
    )
    parser.add_argument(
        "-l",
        "--lowercase",
        action="store_const",
        const=True,
        help=(
            "If lowercase letters can be in the password."
            " Defaults to true unless any of -udsn are given."
        ),
    )
    parser.add_argument(
        "-u",
        "--uppercase",
        action="store_const",
        const=True,
        help=(
            "If uppercase letters can be in the password."
            " Defaults to true unless any of -ldsn are given."
        ),
    )
    parser.add_argument(
        "-d",
        "--digits",
        action="store_const",
        const=True,
        help=(
            "If digits can be in the password."
            " Defaults to true unless any of -lusn are given."
        ),
    )
    parser.add_argument(
        "-s",
        "--symbols",
        action="store_const",
        const=True,
        help=(
            "If password-safe symbols can be in the password."
            " Defaults to true unless any of -ludn are given."
        ),
    )
    parser.add_argument(
        "-n",
        "--unsafe-symbols",
        action="store_const",
        const=True,
        help=(
            "If password-unsafe symbols can be in the password."
            " Defaults to false unless any of -luds are given."
        ),
    )
    args = parser.parse_args(sys.argv[1:])

    # Defaults for character set flags
    if (
        args.lowercase is None
        and args.uppercase is None
        and args.digits is None
        and args.symbols is None
        and args.unsafe_symbols is None
    ):
        # All true except unsafe symbols if none are given
        args.lowercase = True
        args.uppercase = True
        args.digits = True
        args.symbols = True
        args.unsafe_symbols = False
    else:
        # All default to false if any are given
        args.lowercase = args.lowercase or False
        args.uppercase = args.uppercase or False
        args.digits = args.digits or False
        args.symbols = args.symbols or False
        args.unsafe_symbols = args.unsafe_symbols or False

    logging.basicConfig(level=logging.DEBUG)

    print(
        generate_password(
            length=args.length,
            lowercase=args.lowercase,
            uppercase=args.uppercase,
            digits=args.digits,
            symbols=args.symbols,
            unsafe_symbols=args.unsafe_symbols,
        )
    )
