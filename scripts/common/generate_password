#!/usr/bin/env python3
from typing import Dict, Generator, Iterable, Set, Tuple
from functools import cache

import argparse
import collections
import enum
import itertools
import logging
import numpy  # TODO: Check numpy for entropy quality
import os
import sys
import tabulate


# Temporary definition for typing purposes.
class Finger:
    pass


class Hands:
    pass


class Keyboard:
    pass


# Custom types
class Finger(enum.Enum):
    LEFT_PINKY = 0
    LEFT_RING = 1
    LEFT_MIDDLE = 2
    LEFT_INDEX = 3
    LEFT_THUMB = 4
    RIGHT_THUMB = 5
    RIGHT_INDEX = 6
    RIGHT_MIDDLE = 7
    RIGHT_RING = 8
    RIGHT_PINKY = 9

    def get_fingers() -> Generator[Finger, None, None]:
        """Yields every finger."""
        for x in Finger:
            try:
                if isinstance(x, Finger):
                    yield x
            except TypeError:
                pass

    def is_left(self):
        """Returns true if a finger is a left finger."""
        return self.value < 5

    def is_right(self):
        """Returns true if a finger is a right finger."""
        return self.value > 4

    def __repr__(self):
        return self.name


Location = numpy.ndarray
KeyPress = Tuple[Finger, Location]

LOG_FORMAT = "%(levelname)s - %(message)s"

logger = logging.getLogger("generate_password")


def generate_password(
    length: int,  # The length of the password to generate.
    lowercase: bool = True,  # If lowercase letters can be in the password.
    uppercase: bool = True,  # If uppercase letters can be in the password.
    digits: bool = True,  # If digits can be in the password.
    symbols: bool = True,  # If password-safe symbols can be in the password.
    unsafe_symbols: bool = False,  # If password-unsafe symbols can be in the password.
) -> str:
    """Generates a random password."""
    keyboard = Keyboard(
        lowercase=lowercase,
        uppercase=uppercase,
        digits=digits,
        symbols=symbols,
        unsafe_symbols=unsafe_symbols,
    )
    hands = Hands(keyboard.resting_locations)

    password = []
    entropy = 0
    for i in range(length):
        # Get a probability distribution for each character
        chars, p = get_char_probability(keyboard, hands, password)
        # Pick a character based on that distribution
        char = numpy.random.choice(chars, p=p)
        # Add it to the password
        password.append(char)
        # Record it to the hands
        hands.record_key_presses(keyboard.get_keys(char))
        # And add the amount of entropy that choice had to the total
        entropy += compute_entropy(p)
    #TODO: Why are we using the wrong shift key?
    hands.test()

    log_password_stats(len(keyboard.chars), length, entropy)
    return "".join(password)


def get_char_probability(
    keyboard: Keyboard,  # The keyboard being used.
    hands: Hands,  # The hands typing the password.
    password: Iterable[str],  # The password so far.
) -> Tuple[numpy.ndarray[str], numpy.ndarray[float], float]:
    """Computes the probability of each character being selected next in the
    password.

    Return types:
      1: a numpy array of each character
      2: a numpy array of the probability of each character being selected
    """
    # Compute how hard it is to reach each key
    reachability = numpy.array([hands.get_reachability(c) for c in keyboard.chars])
    # Convert scores into a probability distribution
    p = reachability / reachability.sum()
    return keyboard.chars, p


class Hands:
    """A class for a pair of hands typing."""

    def __init__(self, resting_locations: Dict[Finger, Location]):
        """Create a pair of hands."""
        self.__resting_locations = resting_locations
        self.reset()

    def reset(self):
        """Reset hands to their resting locations."""
        self.__time = -1
        self.__location_history = {}
        for finger, location in self.__resting_locations.items():
            self.__location_history[finger] = {self.__time: location}
        self.__time += 1

    def test(self):
        for finger, history in self.__location_history.items():
            print(finger, history)

    def get_reachability(
        self,
        key_presses: Iterable[KeyPress],  # A set of key trying to be pressed.
    ) -> float:
        """Returns how "reachable" pressing a set of keys at the same time
        would be."""
        return 1

    def record_key_presses(
        self,
        key_presses: Iterable[KeyPress],  # A set of key presses to record.
    ) -> None:
        """Records a set of key presses."""
        for finger, location in key_presses:
            self.__location_history[finger][self.__time] = location
        self.__time += 1

    # def get_char_reachability(
    #     self,
    #     pressed_chars: Iterable[str] = tuple(),  # What chars have been entered so far.
    # ) -> Tuple[numpy.ndarray[str], numpy.ndarray[float]]:
    #     """Returns a score of how "reachable" a character is, given what
    #     characters have been pressed.

    #     Return type is a numpy array of each valid character and a second
    #     numpy array of the same size, where each"""
    #     reachability = numpy.ones(len(self.chars))
    #     # If nothing has been pressed, return equal probability for all characters
    #     if not pressed_chars:
    #         return self.chars, reachability

    #     # Compute reachability for each character
    #     for i, char in enumerate(self.chars):
    #         last_char = pressed_chars[-1]
    #         if self.__uses_only_same_hand(last_char, char):
    #             reachability[i] *= 0.5
    #         if self.__is_finger_stretch(last_char, char):
    #             reachability[i] *= 0.25
    #         if self.__uses_same_finger(last_char, char):
    #             reachability[i] *= 0.125
    #     return self.chars, reachability

    # ##### Finger positioning #####

    # def __is_finger_stretch(self, finger1: LocationLike, finger2: LocationLike) -> bool:
    #     """Returns true if two character/location/set of locations would stretch
    #     two fingers on the same hand in opposite directions."""
    #     left_locations = []
    #     right_locations = []
    #     # Find each location that belongs to the left or right hand
    #     for finger in finger1, finger2:
    #         for location in self.__to_locations(finger):
    #             if self.__uses_left_hand(location):
    #                 left_locations.append(location)
    #             else:
    #                 right_locations.append(location)
    #     # For each hand...
    #     for locations in left_locations, right_locations:
    #         # Compute the offset each finger is making to reach each key
    #         offsets = tuple(
    #             x - self.finger_map[self.__get_finger(x)] for x in locations
    #         )
    #         # For each pair of key locations...
    #         for location1, location2 in itertools.combinations(offsets, 2):
    #             distance = numpy.linalg.norm(
    #                 (location1 - location2) / numpy.array((2, 3))
    #             )
    #             if distance >= 1:
    #                 return True
    #     return False

    # def __uses_different_hands(self, a: LocationLike, b: LocationLike) -> bool:
    #     """Returns true if two character/location/set of locations use different
    #     hands."""
    #     return (self.__uses_only_left_hand(a) and self.__uses_only_right_hand(b)) or (
    #         self.__uses_only_right_hand(a) and self.__uses_only_left_hand(b)
    #     )

    # def __uses_only_same_hand(self, a: LocationLike, b: LocationLike) -> bool:
    #     """Returns true if two character/location/set of locations use different
    #     hands."""
    #     return (self.__uses_only_left_hand(a) and self.__uses_only_left_hand(b)) or (
    #         self.__uses_only_right_hand(a) and self.__uses_only_right_hand(b)
    #     )

    # def __uses_same_hand(self, a: LocationLike, b: LocationLike) -> bool:
    #     """Returns true if two character/location/set of locations use the same
    #     single hand to type."""
    #     return (self.__uses_left_hand(a) and self.__uses_left_hand(b)) or (
    #         self.__uses_right_hand(a) and self.__uses_right_hand(b)
    #     )

    # def __uses_both_hands(self, x: LocationLike) -> bool:
    #     """Returns true if a char/location/locations uses both hands."""
    #     return self.__uses_left_hand(x) and self.__uses_right_hand(x)

    # def __uses_only_right_hand(self, x: LocationLike) -> bool:
    #     """Returns true if a char/location/locations uses only the right hand."""
    #     return all(not self.__is_left_finger(f) for f in self.__to_fingers(x))

    # def __uses_right_hand(self, x: LocationLike) -> bool:
    #     """Returns true if a char/location/locations uses the right hand."""
    #     return any(not self.__is_left_finger(f) for f in self.__to_fingers(x))

    # def __uses_only_left_hand(self, x: LocationLike) -> bool:
    #     """Returns true if a char/location/locations uses only the left hand."""
    #     return all(self.__is_left_finger(f) for f in self.__to_fingers(x))

    # def __uses_left_hand(self, x: LocationLike) -> bool:
    #     """Returns true if a char/location/locations uses the left hand."""
    #     return any(self.__is_left_finger(f) for f in self.__to_fingers(x))

    # def __uses_same_finger(self, a: LocationLike, b: LocationLike) -> bool:
    #     """Returns true if a character/location/set of locations uses the same
    #     finger as another character/location/set of locations."""
    #     return bool(self.__to_fingers(a) & self.__to_fingers(b))

    # def __is_finger_jump(self, a: LocationLike, b: LocationLike) -> bool:
    #     """Returns true if pair of characters/locations/set of locations
    #     would require the same finger to jump from one location to another."""

    # def __to_fingers(self, x: LocationLike) -> Set[Finger]:
    #     """Converts a char, location, or Locations into fingers."""
    #     return set(self.__get_finger(l) for l in self.__to_locations(x))

    # def __to_locations(self, x: LocationLike) -> Locations:
    #     """Converts a char, Location, or Locations into Locations."""
    #     if isinstance(x, str):
    #         return self.char_map[x]
    #     elif isinstance(x, numpy.ndarray):
    #         return (x,)
    #     elif isinstance(x, Tuple):
    #         return x
    #     raise ValueError(f"Unable to convert {x} into Locations.")

    # def __is_left_finger(self, f: Finger) -> bool:
    #     """Returns true if a finger is a left finger."""
    #     return f < 5


class Keyboard:
    """A class for a keyboard."""

    ##### Keyboard-specific settings #####

    # The keys each finger rests on (including thumbs)
    home_row = "asdf  jkl;"
    # What columns each finger is responsible for.
    # 0=left pinky, 4=left thumb, 5=right thumb, 9=right pinky
    column_to_finger = "0012336667899"
    # Each row of keys on the keyboard, when shift isn't pressed.
    # Capital S = Shift key
    keys = (
        "`12345=67890-",
        " qwert yuiop\\",
        " asdfg hjkl;'",
        "Szxcvb nm,./S",
        "          [] ",
    )
    # Each row of keys on the keyboard, when shift is pressed.
    shift_keys = (
        "~!@#$%+^&*()_",
        " QWERT YUIOP|",
        ' ASDFG HJKL:"',
        " ZXCVB NM<>? ",
        "          {} ",
    )
    # Each set of characters that could be used in a password.
    lowercase = "abcdefghijklmnopqrstuvwxyz"
    uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    digits = "0123456789"
    symbols = "_-,:!?.()[]{}@*#%^+<=>~"
    # TODO: Add space support
    unsafe_symbols = ";'\"/\\&`|$"

    ##### Initialization / Location mapping #####

    def __init__(self, **kwargs):
        """Create a Keyboard instance."""
        self.set_valid_chars(**kwargs)
        self.__locations = self.__compute_char_map()
        self.resting_locations = self.__compute_home_row_map()

    def get_keys(self, char: str) -> Iterable[KeyPress]:
        """Returns the key press(es) needed to enter a character."""
        return self.__locations[char]

    def get_resting_location(self, finger: Finger) -> Location:
        """Returns the resting location of a finger."""
        return self.__resting_locations[finger]

    def set_valid_chars(
        self,
        lowercase: bool,  # If lowercase letters can be in the password.
        uppercase: bool,  # If uppercase letters can be in the password.
        digits: bool,  # If digits can be in the password.
        symbols: bool,  # If password-safe symbols can be in the password.
        unsafe_symbols: bool,  # If password-unsafe symbols can be in the password.
    ) -> None:
        """Sets what characters can be in the password."""
        chars = []
        if lowercase:
            chars.extend(self.lowercase)
        if uppercase:
            chars.extend(self.uppercase)
        if digits:
            chars.extend(self.digits)
        if symbols:
            chars.extend(self.symbols)
        if unsafe_symbols:
            chars.extend(self.unsafe_symbols)
        self.chars = numpy.array(chars)

    def __compute_char_map(self) -> Dict[str, Iterable[Tuple[Finger, Location]]]:
        """Computes the finger locations required to press each character
        on the keyboard."""
        logger.debug("Generating character location map...")
        char_map = {}
        for key_set_name, key_set in (
            ("keys", self.keys),
            ("shift_keys", self.shift_keys),
        ):
            for y, key_row in enumerate(key_set):
                if len(self.column_to_finger) != len(key_row):
                    raise ValueError(
                        f"Row {y} of self.{key_set_name} has a different number"
                        f" of columns than self.column_to_finger"
                        f" ({len(key_row)} vs {len(self.column_to_finger)})."
                    )
                for x, char in enumerate(key_row):
                    location = numpy.array((x, y))
                    finger = self.__get_finger(location)
                    finger_location = (finger, location)
                    if char == " ":
                        continue
                    # Special keys
                    elif key_set_name == "keys" and char.isupper():
                        if char == "S":
                            if finger.is_left():
                                char_map["LEFT_SHIFT"] = (finger_location,)
                            else:
                                char_map["RIGHT_SHIFT"] = (finger_location,)
                    # Shift keys
                    elif key_set_name == "shift_keys":
                        # Figure out what shift key needs to be pressed
                        if finger.is_left():
                            shift = char_map["RIGHT_SHIFT"]
                        else:
                            shift = char_map["LEFT_SHIFT"]
                        # And then add the character location + shift
                        char_map[char] = (
                            finger_location,
                            *char_map["RIGHT_SHIFT"],
                        )
                    # Normal keys
                    else:
                        char_map[char] = (finger_location,)
        return char_map

    def __compute_home_row_map(self) -> Dict[Finger, Location]:
        """Computes the location of each finger on the keyboard."""
        logger.debug("Generating finger location map...")
        home_row_map = {}
        for resting_char in self.home_row:
            # TODO: Add thumb support
            if resting_char == " ":
                continue
            finger, location = self.get_keys(resting_char)[0]
            home_row_map[finger] = location
        return home_row_map

    def __get_finger(self, l: Location) -> Finger:
        """Returns the finger that presses a location."""
        return Finger(int(self.column_to_finger[l[0]]))


# Stats


def compute_entropy(p: numpy.ndarray[float]) -> float:
    """Computes the entropy of a probability distribution."""
    p_norm = p / p.sum()
    return sum(-x * numpy.log2(x) for x in p_norm if x > 0)


def log_password_stats(
    num_chars: int,  # The number of unique characters available for the password.
    length: int,  # The length of the password generated.
    entropy: float,  # The entropy of the password generated.
) -> None:
    """Generates useful stats about the password generated."""
    headers = compute_password_stats()
    data = []
    # Compute stats of generated password
    data.append(compute_password_stats("Generated", length, entropy))
    # Compute stats of random passwords
    random_entropy = compute_entropy(numpy.ones(num_chars))
    lengths = {
        length,
        numpy.floor(entropy / random_entropy),
        numpy.ceil(entropy / random_entropy),
    }
    for length in sorted(lengths):
        data.append(compute_password_stats("Random", length, random_entropy * length))
    # Print it as a table
    table = tabulate.tabulate(data, headers, stralign="right")
    logger.info(f"Password info:\n{table}")


def compute_password_stats(
    title: str = None,  # A title to give the password.
    length: int = None,  # The length of the password.
    entropy: float = None,  # The entropy of the password.
) -> Tuple[str, str, str, str]:
    """Computes stats for a single password."""
    if title is None:
        return ("", "Length", "Entropy", "Brute Force Time")

    brute_force = 2**entropy / 10000000000 / 3600 / 24 / 365.25
    return (
        title,
        f"{length:.0f} chars",
        f"{entropy:.1f} bits",
        seconds_to_human_time(brute_force),
    )


# Time

SECOND_SECONDS = 1
MINUTE_SECONDS = 60
HOUR_SECONDS = MINUTE_SECONDS * 60
DAY_SECONDS = HOUR_SECONDS * 24
MONTH_SECONDS = DAY_SECONDS * 365.25 / 12
YEAR_SECONDS = MONTH_SECONDS * 12
DECADE_SECONDS = YEAR_SECONDS * 10
CENTURY_SECONDS = DECADE_SECONDS * 10
MILLENNIUM_SECONDS = CENTURY_SECONDS * 10
EON_SECONDS = MILLENNIUM_SECONDS * 1000000

TIME_COMPONENTS = (
    ("eon", "eons"),
    ("millennium", "millennia"),
    ("century", "centuries"),
    ("decade", "decades"),
    ("year", "years"),
    ("month", "months"),
    ("day", "days"),
    ("hour", "hours"),
    ("minute", "minutes"),
    ("second", "seconds"),
)


def seconds_to_human_time(total_seconds: float) -> str:
    """Converts seconds into a human-readable time string, rounded down to the
    1's place of the largest time component e.g. 2 days or 35 minutes."""
    remainder = total_seconds
    # For years/months/days/...
    for singular, plural in TIME_COMPONENTS:
        # Find the number of seconds in a year/month/day/...
        divider = globals()[f"{singular.upper()}_SECONDS"]
        # Compute the number of years/months/days/... and the remainder seconds left
        amount, remainder = divmod(remainder, divider)
        amount = round(amount)  # Convert to int
        if amount == 0:
            continue
        elif amount == 1:
            return f"{amount} {singular}"
        else:
            return f"{amount} {plural}"
    return "less than 1 second"


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog=os.path.basename(__file__))
    parser.add_argument(
        "length",
        type=int,
        help="The number of characters to include in the password.",
    )
    parser.add_argument(
        "--log",
        choices=("trace", "debug", "info", "warning", "error"),
        default="warning",
        help="The level to log at. Defaults to warning.",
    )
    parser.add_argument(
        "-l",
        "--lowercase",
        action="store_const",
        const=True,
        help=(
            "If lowercase letters can be in the password."
            " Defaults to true unless any of -udsn are given."
        ),
    )
    parser.add_argument(
        "-u",
        "--uppercase",
        action="store_const",
        const=True,
        help=(
            "If uppercase letters can be in the password."
            " Defaults to true unless any of -ldsn are given."
        ),
    )
    parser.add_argument(
        "-d",
        "--digits",
        action="store_const",
        const=True,
        help=(
            "If digits can be in the password."
            " Defaults to true unless any of -lusn are given."
        ),
    )
    parser.add_argument(
        "-s",
        "--symbols",
        action="store_const",
        const=True,
        help=(
            "If password-safe symbols can be in the password."
            " Defaults to true unless any of -ludn are given."
        ),
    )
    parser.add_argument(
        "-n",
        "--unsafe-symbols",
        action="store_const",
        const=True,
        help=(
            "If password-unsafe symbols can be in the password."
            " Defaults to false unless any of -luds are given."
        ),
    )
    args = parser.parse_args(sys.argv[1:])

    # Defaults for character set flags
    if (
        args.lowercase is None
        and args.uppercase is None
        and args.digits is None
        and args.symbols is None
        and args.unsafe_symbols is None
    ):
        # All true except unsafe symbols if none are given
        args.lowercase = True
        args.uppercase = True
        args.digits = True
        args.symbols = True
        args.unsafe_symbols = False
    else:
        # All default to false if any are given
        args.lowercase = args.lowercase or False
        args.uppercase = args.uppercase or False
        args.digits = args.digits or False
        args.symbols = args.symbols or False
        args.unsafe_symbols = args.unsafe_symbols or False

    logging.basicConfig(level=args.log.upper(), format=LOG_FORMAT)

    print(
        generate_password(
            length=args.length,
            lowercase=args.lowercase,
            uppercase=args.uppercase,
            digits=args.digits,
            symbols=args.symbols,
            unsafe_symbols=args.unsafe_symbols,
        )
    )
